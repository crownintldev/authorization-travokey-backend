import{ForbiddenError as t,wrapArray as n}from"@casl/ability";import{rulesToQuery as r,permittedFieldsOf as e}from"@casl/ability/extra";function o(t){const n=t.conditions;return t.inverted?{$nor:[n]}:n}function c(t,n,e="read"){return r(t,e,n,o)}function i(t,n="read"){return new Proxy({t:t,o:n},u)}const s={$expr:{$eq:[0,1]}};const u={get(t,n){const e=r(t.t,t.o,n,o);return e===null?s:e}};function f(n,r,e,o){o.where(s);const c=o;if(typeof c.pre==="function")c.pre((o=>{const c=t.from(n).unlessCan(r,e);o(c)}));return o}function l(t,n,r){const e=n.detectSubjectType({constructor:t.model});if(!e)throw new TypeError(`Cannot detect subject type of "${t.model.modelName}" to return accessible records`);const o=c(n,e,r);if(o===null)return f(n,r||"read",e,t.where());return t.and([o])}function a(t,n){return l(this.where(),t,n)}function d(t,n){return l(this,t,n)}function y(t){t.query.accessibleBy=d;t.statics.accessibleBy=a}const b=t=>Object.keys(t.paths);function p(t,r){const e=r.getFields(t);if(!r||!("except"in r))return e;const o=n(r.except);return e.filter((t=>o.indexOf(t)===-1))}function m(){let t;return(r,e)=>{if(!t){const o=e&&"only"in e?n(e.only):p(r,e);t=t=>t.fields||o}return t}}function h(t,n){const r=Object.assign({getFields:b},n);const o=m();function c(n,c){return e(n,c||"read",this,{fieldsFrom:o(t,r)})}function i(n,c){const i={constructor:this};return e(n,c||"read",i,{fieldsFrom:o(t,r)})}t.statics.accessibleFieldsBy=i;t.method("accessibleFieldsBy",c)}export{i as accessibleBy,h as accessibleFieldsPlugin,y as accessibleRecordsPlugin,b as getSchemaPaths,c as toMongoQuery};
//# sourceMappingURL=index.mjs.map
